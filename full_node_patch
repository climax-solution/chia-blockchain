diff --cc src/full_node/full_node.py
index c1078577,c1078577..c62b915e
--- a/src/full_node/full_node.py
+++ b/src/full_node/full_node.py
@@@ -4,7 -4,7 +4,7 @@@ import loggin
  import time
  import traceback
  from pathlib import Path
--from typing import AsyncGenerator, Optional, Dict, Callable, List, Tuple, Any, Union, Set
++from typing import Optional, Dict, Callable, List, Tuple, Any, Union, Set
  
  import aiosqlite
  from blspy import AugSchemeMPL
@@@ -35,9 -35,9 +35,10 @@@ from src.protocols import 
      farmer_protocol,
  )
  from src.protocols.full_node_protocol import RequestSubBlocks, RejectSubBlocks, RespondSubBlocks, RespondSubBlock
++from src.protocols.protocol_message_types import ProtocolMessageTypes
  
  from src.server.node_discovery import FullNodePeers
--from src.server.outbound_message import Message, NodeType, OutboundMessage
++from src.server.outbound_message import Message, NodeType, make_msg
  from src.server.server import ChiaServer
  from src.types.full_block import FullBlock
  from src.types.pool_target import PoolTarget
@@@ -49,8 -49,8 +50,6 @@@ from src.util.errors import ConsensusEr
  from src.util.ints import uint32, uint128, uint8
  from src.util.path import mkdir, path_from_root
  
--OutboundMessageGenerator = AsyncGenerator[OutboundMessage, None]
--
  
  class FullNode:
      block_store: BlockStore
@@@ -233,8 -233,8 +232,8 @@@
                  tip_height = response.wp.recent_chain_data[-1].reward_chain_sub_block.sub_block_height
                  self.sync_store.add_potential_peak(response.tip, tip_height, tip_weight)
                  self.sync_store.add_potential_fork_point(response.tip, fork_point)
--                msg = Message(
--                    "request_sub_block",
++                msg = make_msg(
++                    ProtocolMessageTypes.request_sub_block,
                      full_node_protocol.RequestSubBlock(uint32(tip_height), True),
                  )
                  await peer.send_message(msg)
@@@ -266,7 -266,7 +265,7 @@@
                  last_csb_or_eos = curr.total_iters
              else:
                  last_csb_or_eos = curr.ip_sub_slot_total_iters(self.constants)
--            timelord_new_peak: timelord_protocol.NewPeak = timelord_protocol.NewPeak(
++            timelord_new_peak: timelord_protocol.NewPeakTimelord = timelord_protocol.NewPeakTimelord(
                  peak_block.reward_chain_sub_block,
                  difficulty,
                  peak.deficit,
@@@ -276,7 -276,7 +275,7 @@@
                  last_csb_or_eos,
              )
  
--            msg = Message("new_peak", timelord_new_peak)
++            msg = Message("new_peak_timelord", timelord_new_peak)
              await self.server.send_to_all([msg], NodeType.TIMELORD)
  
      async def on_connect(self, connection: ws.WSChiaConnection):
@@@ -313,13 -313,13 +312,13 @@@
  
              elif connection.connection_type is NodeType.WALLET:
                  # If connected to a wallet, send the Peak
--                request_wallet = wallet_protocol.NewPeak(
++                request_wallet = wallet_protocol.NewPeakWallet(
                      peak.header_hash,
                      peak.sub_block_height,
                      peak.weight,
                      peak.sub_block_height,
                  )
--                await connection.send_message(Message("new_peak", request_wallet))
++                await connection.send_message(Message("new_peak_wallet", request_wallet))
              elif connection.connection_type is NodeType.TIMELORD:
                  await self.send_peak_to_timelords()
  
@@@ -519,13 -519,13 +518,13 @@@
                  self.blockchain.sub_blocks,
              )
              await self.weight_proof_handler.get_proof_of_weight(peak.header_hash)
--            request_wallet = wallet_protocol.NewPeak(
++            request_wallet = wallet_protocol.NewPeakWallet(
                  peak.header_hash,
                  peak.sub_block_height,
                  peak.weight,
                  peak.sub_block_height,
              )
--            msg = Message("new_peak", request_wallet)
++            msg = Message("new_peak_wallet", request_wallet)
              await self.server.send_to_all([msg], NodeType.WALLET)
              self._state_changed("sub_block")
  
@@@ -714,8 -714,8 +713,8 @@@
  
              # Tell wallets about the new peak
              msg = Message(
--                "new_peak",
--                wallet_protocol.NewPeak(
++                "new_peak_wallet",
++                wallet_protocol.NewPeakWallet(
                      sub_block.header_hash,
                      sub_block.sub_block_height,
                      sub_block.weight,
@@@ -894,7 -894,7 +893,7 @@@
              assert block.reward_chain_sub_block.reward_chain_sp_vdf is not None
              rc_prev = block.reward_chain_sub_block.reward_chain_sp_vdf.challenge
  
--        timelord_request = timelord_protocol.NewUnfinishedSubBlock(
++        timelord_request = timelord_protocol.NewUnfinishedSubBlockTimelord(
              block.reward_chain_sub_block,
              difficulty,
              sub_slot_iters,
@@@ -903,7 -903,7 +902,7 @@@
              rc_prev,
          )
  
--        msg = Message("new_unfinished_sub_block", timelord_request)
++        msg = Message("new_unfinished_sub_block_timelord", timelord_request)
          await self.server.send_to_all([msg], NodeType.TIMELORD)
  
          full_node_request = full_node_protocol.NewUnfinishedSubBlock(block.reward_chain_sub_block.get_hash())
